{
    "contents" : ".packageName <- \"satf\"\n\nDeviance <- function(LL) -2*LL\nAIC <- function(LL, k) Deviance(LL) + 2*k\nBIC <- function(LL, k, n) Deviance(LL) + k*log(n)\n\np2logodds <- function(p) log(p/(1-p))\nlogodds2p <- function(lodds) exp(lodds)/(1+exp(lodds))\n\nNumSmallest <- -.Machine$double.xmax\nNumLargest <- .Machine$double.xmax\n\n\ncompute_logLikFn <- function(coefs, by_row=FALSE, force_update=FALSE, invert=FALSE) {\n\tres = rcpp_compute_logLikFn(coefs, by_row, FALSE, force_update)\n#  print(res)\n  if(invert) return(-res)\n  else       return(res)\n}\n\ncompute_logLikFn_gradient <- function(coefs, by_row=FALSE) {\n  res = rcpp_compute_logLikFn_gradient(coefs, by_row, FALSE)\n  colnames(res) = names(coefs)\n#  print(rbind(coefs,res))\n  res\n}\n\ncompute_logLikFn_gradient_BHHH <- function(coefs) {\n  res = rcpp_compute_logLikFn_gradient(coefs, TRUE, FALSE)\n  colnames(res) = names(coefs)\n#  print(rbind(coefs,res))\n#  stop()\n  res\n}\n\nparameter_combinations <- function(namedlist) {\n  membernames <- names(namedlist)\n  cross_prod = cset(namedlist[[1]])\n  for(i in 2:length(namedlist))\n    cross_prod = cross_prod*cset(namedlist[[i]])\n  llply(as.list(cross_prod), function(x) { x= unlist(x); names(x) = membernames; x })\n}\n\nsatf_gridsearch <- function(start, constraints, ...) {\n  rcpp_deinitialize_logLikFn()\n  start.vec <- parameter_combinations(start)\n  logLik.vec <- laply(start.vec, function(start) {\n    constraints[names(start)] = start\n    res = satf(start=start, constraints=c(constraints,start), ..., stepwise=F, .internal.init.optional=TRUE, .internal.cleanup=FALSE)\n    reportifnot(!is.list(res), \"All coefficient values have to be specified in a grid search.\")\n    res\n  })\n  rcpp_deinitialize_logLikFn()\n  start.vec[[which.max(logLik.vec)]]\n}\n\nsatf <- function(dv, signal, start, contrasts, bias, data, time, metric, trial.id=NULL, constraints=list(), \n                  optimize.incrementally=FALSE, reoptimize.dprime=TRUE, reoptimize.criterion=TRUE, reoptimize.corr=TRUE,\n                  reoptimize.times=1, method=\"SUBPLEX\", # \"Nelder-Mead\", #\"BHHH\",\n                  debug=F, .likelihood.byrow=FALSE, .internal.init.optional=FALSE, .internal.cleanup=TRUE, doit=F)\n{\n  log = function(str) {\n    if(debug) {\n      cat(paste0(str,\"\\n\"))\n    }\n  }\n  log(\"---------- optimizing ---------\")\n  \n  metric.permissible <- c('RMSD','R2','adjR2','logLik','logLikRaw')\n  reportifnot(metric %in% metric.permissible, sprintf(\"'metric' has to be one of: %s\", paste(metric.permissible, collapse=\", \")))\n\n  deinitialize_logLikFn <- function() T\n  if(.internal.cleanup)\n    deinitialize_logLikFn <- rcpp_deinitialize_logLikFn \n  \n  # Check 'data' parameter\n  reportifnot(nrow(data) > 0, \"Parameter 'data' needs to consist of several rows.\")\n  \n  satf.coefnames.core <- c('asymptote', 'invrate', 'intercept')\n  bias.coefnames.core <- c('bias.max', 'bias.invrate', 'bias.intercept','bias.min')\n  \n  return_value = function(estimates, LL) {\n    # if( is.na(LL) ) estimates = estimates*NaN\n    list(estimates=estimates, LL=LL)#, SE=SE, ci.upper=ci.upper, ci.lower=ci.lower)\n  }\n  \n  # set defaults for start values and constraints\n  start = set_start_defaults(start, set.corr.mrsat=!is.null(trial.id))\n  constraints = set_constraints_defaults(constraints)\n  \n  # check parameters\n  params <- translate.parameters(data=data, dv=dv, contrasts=contrasts, bias=bias,\n                                 signal=signal, time=time, trial.id=trial.id)\n\n  skip.initialization <- .internal.init.optional && rcpp_is_initialized_logLikFn()\n  \n  # initialize start parameters and create constraint matrix if necessary\n  if(!skip.initialization) {\n    dm <- init_designmatrix(data=data, contrasts=params$contrasts, bias=params$bias, cnames=params$cnames,\n                            satf.coefnames.core=satf.coefnames.core, bias.coefnames.core=bias.coefnames.core)\n    coefnames <- colnames(dm$dm)\n  } else {\n    coefnames <- rcpp_get_coef_names()\n  }\n  \n  # initialize start parameters and create constraint matrix  \n  coefs <- init_coefs_and_constraints(coefnames=coefnames, start=start, constraints=constraints,\n                                      coreparams=c(satf.coefnames.core, bias.coefnames.core))\n#  # TODO: remove\n#  coefs$constraints[,'upper'] = Inf\n#  coefs$constraints[,'lower'] = -Inf\n#  print(coefs$constraints)\n  \n  # initialize the C++ optimization routine\n  if( !skip.initialization ) {\n    rcpp_initialize_logLikFn(params$dv, dm$dm, dm$dm.coef.cnt, coefs$constraints, data, params$cnames)\n  } else {\n    rcpp_update_constraints_logLikFn(coefs$constraints)\n  }\n  \n  start <- rcpp_unconstrain_coefs( coefs$start )\n  names(start) <- names( coefs$start )\n  \n  if(all(names(start) %in% coefs$fixed.coefs)) {\n    if(.likelihood.byrow) {\n      logLik = compute_logLikFn(start, TRUE, TRUE)\n      deinitialize_logLikFn()\n      return( return_value( rcpp_constrain_coefs(start), logLik) )\n      \n    } else {\n      logLik = compute_logLikFn(start, FALSE, TRUE)\n      deinitialize_logLikFn()\n      return( return_value( rcpp_constrain_coefs(start), logLik) )\n    }\n  }\n\n  # make sure the start values yield a valid likelihood\n  logLik = compute_logLikFn(start)\n  if( is.na(logLik) ) {\n    if(.likelihood.byrow)\n     \tres = compute_logLikFn(start, TRUE, FALSE)\n    start = rcpp_constrain_coefs(start)\n    deinitialize_logLikFn()\n    warning(\"Got NA on first iteration. Adjust start parameters.\")\n    return( return_value( start, logLik) )\n    \n  } else if( is.infinite(logLik) ) {\n    if(.likelihood.byrow)\n      logLik = compute_logLikFn(start, TRUE, FALSE)\n    start = rcpp_constrain_coefs(start)\n    deinitialize_logLikFn()\n    warning(\"Got Inf or -Inf on first iteration. Adjust start parameters.\")\n    return( return_value( start, logLik) )\n  }\n\n# TODO: Re-enable and do it again.\n#  if(doit ==T) {\n#  print( compareDerivatives(f=compute_logLikFn, grad=compute_logLikFn_gradient, t0=start) )\n#  stop()\n#  }\n  \n  optimize_subset <- function(variable, start, all=TRUE, selection=c(), method=\"Nelder-Mead\") {\n    .optimize_subset(variable, coefs$fixed.coefs, method, start, debug, data, selection)\n  }\n\n  log_step_n = function(n) {\n    if(debug) {\n      cat(\"-------------------\\n\")\n      cat(sprintf(\"optimization step %d\\n\", n))\n      cat(\"-------------------\\n\")\n    }\n  }\n  \n\n  original.start = start\n\n  n.step = 0\n  if(optimize.incrementally)\n  {\n    # ignore correlation parameter for now, if specified\n    rcpp_set_coef_values( c(corr.mrsat=0) )\n    \n    # TODO: Implement the following.\n    reportifnot(!.internal.init.optional, \"The package does not support optimize.incrementally=T with .internal.init.optional=T. It's on my to-do list.\")\n    coeforder = append(dm$params.criterion, dm$params.dprime)\n    cur.start = start\n    # optimize in steps on subsets of the data\n    for(n.step in 1:length(coeforder)) {\n      log_step_n(n.step)\n      selection.variables = c( unlist(coeforder[1:n.step]),  'corr.mrsat' )\n      cur.start = optimize_subset(variable=coeforder[[n.step]], start=cur.start, selection=selection.variables) \n      if( any(is.na(cur.start)) ) {\n        break;\n      }\n    }\n    if( !any(is.nan(cur.start)) ) {\n        start = cur.start\n    }\n    # optimize all of them\n    log_step_n(n.step+1)\n    start = optimize_subset(variable=c(unlist(dm$params.dprime), unlist(dm$params.criterion)), start=start, method=method) \n    \n    # re-enable and optimize the correlation coefficient\n    rcpp_reset_coef_ranges( 'corr.mrsat' )\n    log_step_n(n.step+2)\n    estimates = optimize_subset(variable='corr.mrsat', start=start, method=method) \n    if(any(is.na(estimates))) # Optimizing subsets of parameters has failed. Optimize over all of them together.\n    {\n      start = original.start\n      reoptimize.dprime = TRUE\n      reoptimize.criterion = TRUE\n      reoptimize.corr = TRUE\n    } else {\n      start = estimates\n    }\n  }\n\n    \n  # reoptimize dprime or more parameters\n  free.variables = c()\n  if(reoptimize.dprime)    free.variables = c(free.variables, unlist(dm$params.dprime))\n  if(reoptimize.criterion) free.variables = c(free.variables, unlist(dm$params.criterion))\n  if(reoptimize.corr)      free.variables = c(free.variables, 'corr.mrsat') \n  for(i in 1:reoptimize.times) {  \n    log_step_n(n.step+i+2)\n    estimates = optimize_subset(variable=free.variables, start=start, method=method)\n    start = estimates\n  }\n\n  if(.likelihood.byrow) {\n    logLik = compute_logLikFn(coefs=estimates, by_row=TRUE)\n    estimates = rcpp_constrain_coefs(estimates)\n    deinitialize_logLikFn()\n    return( return_value(estimates, logLik) )\n  } \n\n  # recompute the likelihood for the entire dataset\n  logLik <- compute_logLikFn( coefs= estimates, by_row=FALSE)\n  constrained.estimates = rcpp_constrain_coefs(estimates)\n  deinitialize_logLikFn()\n\n  return( return_value(estimates=constrained.estimates, logLik) )\n}\n\n.optimize_subset <- function(variable, fixed, method, start, debug, data, selection, nosummary=TRUE)\n{\n  # NOTE: 'fixed' overrides 'variable'\n  # extract start values if necessary\n  original.start = start\n  if(is.list(start))\n    start = coef(start)\n  \n  # determine which variables should vary, and which are fixed\n  variable.coefnames = setdiff(variable, fixed)\n  fixed.coefnames = setdiff(names(start), variable.coefnames)\n  fixed = names(start) %in% fixed.coefnames\n  \n  # if all are fixed, return the original coefs\n  if( all(fixed) )\n    return(original.start)\n  \n  n.free = sum(!fixed)\n  if(n.free == 1 && method==\"Nelder-Mead\") {\n    method = \"CG\" # Nelder-Mead can't handle one-parameter optimization\n  }\n    \n  fnLogLik = compute_logLikFn\n  \n  # set gradient, etc.\n  if(method == \"Nelder-Mead\")\n    fnLogLikGradient = NULL\n  else if(method == \"BHHH\")\n    fnLogLikGradient = compute_logLikFn_gradient_BHHH\n  else\n    fnLogLikGradient = compute_logLikFn_gradient\n  \n  if(debug) print.level=0\n  else      print.level=0\n  \n  # select the required data subset\n  if(length(selection) > 0) {\n    rcpp_select_coef_subset( selection )\n  }\n\n  if(debug) {\n    variable.coefnames <- variable.coefnames[variable.coefnames%in%names(start)]\n    cat(sprintf(\"optimizing: %s\\n\", paste(variable.coefnames, collapse=', ') ))\n    cat(sprintf(\"data points: %d\\n\", length(rcpp_return_selection()) ))\n  }\n  \n  generate_parscale <- function(start) {pmax(abs(start), .1)}\n  \n  logLik = compute_logLikFn(start)\n  if(is.na(logLik) || is.infinite(logLik)) {\n    estimates = start*NaN     \n    rcpp_reset_selection()\n    return(estimates)\n  }\n  if(method==\"SUBPLEX\") {\n    reportifnot(all(!fixed), \"Fixed parameters not yet supported when using SUBPLEX.\")\n    res = nloptr(x0=start, eval_f=fnLogLik, by_row=FALSE, force_update=FALSE, invert=TRUE, opts=list(algorithm=\"NLOPT_LN_SBPLX\", maxeval=10^6))\n    # TODO: translate status to code (maxLik codes) if necessary\n    mapped.res = list(code=res$status, iterations = res$iterations, estimates=res$solution) \n    names(mapped.res$estimates) = names(start)\n    res = mapped.res\n    nosummary = TRUE\n    coef = function(obj) obj$estimates\n  } else if(method==\"Nelder-Mead\") {\n    res = maxLik(logLik=fnLogLik, grad=fnLogLikGradient, start=start, fixed=fixed,\n                 iterlim=10^6, method=method, print.level=print.level, parscale=generate_parscale(start))\n  } else {\n    res = maxLik(logLik=fnLogLik, grad=fnLogLikGradient, start=start, fixed=fixed,\n                 iterlim=10^6, method=method, print.level=print.level)\n  }\n  i = 0\n  switched_to_NM = FALSE\n  while(res$code %in% c(3)) {  ## 100: Initial value out of range. 3: Boundary of parameter space.\n    warning(\"Optimization routine got code 3. Restarting with Nelder-Mead.\")\n    cat(\"Optimization routine got code 3. Restarting with Nelder-Mead.\\n\")\n    method = \"Nelder-Mead\"\n    if(!nosummary)\n      print(summary(res))\n    switched_to_NM = TRUE\n    i = i + 1\n    if(i > 10) {\n      break;\n    }\n    start = coef(res)\n    if(method==\"Nelder-Mead\") {\n      res = maxLik(logLik=fnLogLik, grad=fnLogLikGradient, start=start, fixed=fixed,\n                   iterlim=10^6, method=method, print.level=print.level, parscale=generate_parscale(start))\n    } else {\n      res = maxLik(logLik=fnLogLik, grad=fnLogLikGradient, start=start, fixed=fixed,\n                   iterlim=10^6, method=method, print.level=print.level)\n    }\n    if(debug && !nosummary) {\n      print(summary(res))\n    }\n  }\n#  if(switched_to_NM) {\n#    start = coef(res)\n#    res = maxLik(logLik=fnLogLik, grad=fnLogLikGradient, start=start, fixed=fixed,\n#                 iterlim=10^6, method=method, print.level=print.level)\n#  }\n  if(debug) {\n    cat(sprintf(\"method: %s\\n\", method))\n    cat(sprintf(\"code: %d\\n\", res$code))\n    cat(sprintf(\"iterations: %d\\n\", res$iterations))\n    if(!nosummary)\n      print(summary(res))\n  }\n  if(res$code %in% c(3,100)) { ## 100: Initial value out of range. 3: Boundary of parameter space.\n    estimates = start*NaN     \n    se = start*NaN\n  } else {\n    estimates = coef(res)\n    if(nosummary)\n      se = start*NaN\n    else\n      se = coef(summary(res))[,'Std. error']\n  }\n  \n  if(debug) {\n    cat(\"coefs\\n\")\n    constrained.coefs = rcpp_constrain_coefs( estimates )\n    idx = which(names(constrained.coefs)%in%variable.coefnames)\n    names(constrained.coefs)[idx] = paste0('*',names(constrained.coefs)[idx],'*')\n    newnames = names(constrained.coefs)\n    constrained.coefs = sprintf(\"%.2f\", constrained.coefs)\n    names(constrained.coefs) = newnames\n    print(constrained.coefs)\n    old.LL = compute_logLikFn( coefs=start, by_row=FALSE)\n    new.LL = compute_logLikFn( coefs=estimates, by_row=FALSE)\n    cat(sprintf(\"LL improved by %.2f (old LL = %.2f, new LL = %.2f)\\n\", new.LL-old.LL, old.LL, new.LL))\n  }\n  rcpp_reset_selection()\n  estimates\n}\n",
    "created" : 1385758290819.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1099038160",
    "id" : "EC743D7A",
    "lastKnownWriteTime" : 1397422804,
    "path" : "~/CodeSATF/R/satf.R",
    "project_path" : "R/satf.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}